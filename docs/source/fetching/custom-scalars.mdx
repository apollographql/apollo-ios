---
title: Custom Scalars
---

In addition to its [built-in scalar types](https://graphql.org/learn/schema/#scalar-types) (`Int`, `String`, etc.), GraphQL supports defining [custom scalars](/apollo-server/schema/custom-scalars/). For example, your schema might provide a custom scalar for `Date`, `UUID`, or `GeoLocation`.

Custom Scalars are initially defined as part of a schema. To interact with a schema using custom scalars, your client must define a Swift type to use for each custom scalar.

Apollo iOS automatically defines Swift types for all of the [built-in scalar types](https://graphql.org/learn/schema/#scalar-types):

| GraphQL Type | Swift Type |
| -------------|------------|
| `Int`        | `Int`      |
| `Float`      | `Double`   |
| `Boolean`    | `Bool`     |
| `String`     | `String`   |
| `ID`         | `String`   |

By default, each custom scalar is treated as a Swift `String`, but you can customize the type of all of your custom scalars with Apollo iOS!

# Defining custom scalar types

If any part of your GraphQL application references a custom scalar defined by the schema, a file for it will be generated in your generated schema output. This file can be used to define the Swift type for the custom scalar.

For example, in a schema that defines a custom scalar:

```graphql title="MySchema.graphqls"
 scalar UUID
```

Apollo iOS generates a `UUID` custom scalar type in your generated schema output. This generated file defines `UUID` as a `String` by default.

```swift title="MySchema/CustomScalars/UUID.swift"
public extension MySchema {
  typealias UUID = String
}
```

The `MySchema.UUID` type will be referenced in any other generated objects that reference the `UUID` scalar.

--------

> **Note:** TODO things change addes new scalars
### TODO Notes on working with Custom Scalars

Custom scalars are types defined by your schema that are based on other GraphQL scalar types (such as `String` or `Int`). Without intervention, code generation will use the underlying types to generate code for the custom scalars.

If you want to use the custom scalars within your code, you must set `passthroughCustomScalars` to true either at the command line or using Swift Scripting.

Once you've done that, you can either create your own type locally or use a `typealias` to declare an equivilent. This is very, very frequently used with `Date` types. Please see the [Custom Scalar Playground Page](https://github.com/apollographql/apollo-client-swift-playground/blob/main/Apollo.playground/Pages/CustomScalars.xcplaygroundpage/Contents.swift) for a full example using a custom date type.

#### TODO JSON and other Custom Scalars with multiple return types

Some custom scalars are set up to potentially return multiple types at runtime. This is not ideal since you lose type safety, but if you're using an API you don't have control over, there's often not a great alternative to this.

When this happens, because you don't know the type that's coming in, you can't set up a single `typealias` for that scalar. Instead, you need to define some other way of instantiating your custom scalar object.

This happens most often with JSON, which can return either an array or a dictionary. Here's an example of how you can use an enum to allow dynamic-but-limited types to parse (with `CustomJSON` as a placeholder type name`):

```swift
enum CustomJSON {
  case dictionary([String: Any])
  case array([Any])
}

extension CustomJSON: JSONDecodable {
  init(jsonValue value: JSONValue) throws {
    if let dict = value as? [String: Any] {
      self = .dictionary(dict)
    } else if let array = value as? [Any] {
      self = .array(array)
    } else {
      throw JSONDecodingError.couldNotConvert(value: value, to: CustomJSON.self)
    }
  }
}
```

Again, make sure to define this in a file that is outside of your generated code, or it will get overwritten.