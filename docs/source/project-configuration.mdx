---
title: Project configuration
description: Structuring a GraphQL application with the Apollo iOS SDK
---

Apollo iOS 1.0 was designed to support complex applications composed of multiple modules as well as monolithic application targets. The code generation engine and modularized structure of the Apollo iOS SDK provide flexible configuration options that aim to make the Apollo libraries and your generated code work seamlessly for any project structure you prefer.

This guide helps you understand the contents of the models generated by Apollo iOS, the modules that compose the Apollo iOS SDK, and how to include these components in your project, depending on its structure.

## Generated models

There are three groups of files the that Apollo iOS generates for your project:

* **[Operation models](#operation-models):** The queries, mutations, subscriptions, and fragments defined in your GraphQL files.
* **[Schema types](#schema-types):** Your GraphQL schema's shared types and metadata such as objects, enums, input objects, etc.
* **[Test mocks](#test-mocks):** Test mocks objects for your schema types that enable creation of operation models for your tests.

#### Operation models

To execute GraphQL requests, you define a series of GraphQL operation files, which contain the queries, mutations, subscriptions, and fragments you can execute. Apollo iOS generates operation models from these definitions. These operation models are classes that represent your queries, mutations, and subscriptions, which can be used to make GraphQL requests with an `ApolloClient`.

Each operation model also includes a set of response models objects, which are type-safe models representing the response receieved by the operation. The `ApolloClient` returns instances of these response models upon successful completion of a GraphQL request using the corresponding operation model.

> To learn more about GraphQL operations, check out [Defining operations](./fetching/fetching-data#defining-operations).

#### Schema types

All GraphQL operations depend upon the types in their corresponding GraphQL schema. Your generated operation models also depend on information from the schema. Apollo iOS generates a collection of types that provide the necessary properties and metadata about the types in your GraphQL schema (ie. objects, interfaces, unions, enums, input objects, etc.). These shared schema types are referenced by your generated operation models to provide type information without duplicated code.

#### Test mocks

Apollo iOS provides the ability to generate test mock objects for use in your test targets. The mocks enable creation of operation models for your tests.

For more information on setting up and using test mocks, see our [test mocks documentation](./testing/test-mocks)

## Configuring your project

When including Apollo iOS in a new project, it's important to decide how you will structure your project, and where your generated GraphQL models fit in that project. Your GraphQL models can be included in your main application target, spread out across many modules, or exposed as an independent module that can be used by multiple applications. Depending on the needs and constraints of your project, you will need to configure the code generation engine and link to the Apollo iOS libraries differently.

There are three primary decisions to be made about your project structure:

> For more specific customization, read about the configuration options below.

### Single target vs multi-module

> ** 1. Will your application consist of a single application target or multiple modules?**

Depending on the size and complexity of your project, it may be built as a single, monolithic application target, or be composed of multiple modules.

For a monolithic application you can simply link your application target to the `Apollo` library. You may optionally, link to `ApolloSQLite` and/or `ApolloWebSocket` to enable their functionality.

To include the Apollo iOS SDK in a project with multiple modules:

- Link `Apollo` to the modules that configure or use the networking and caching APIs.
    - Optionally, link `ApolloSQLite` and/or `ApolloWebSocket` to the module that sets up your `ApolloClient` to enable their functionality.
- Link `ApolloAPI` to the modules that only include generated models.

You may also optionally, link `ApolloTestSupport` to your unit test target to create mocks of your generated models.

> For more information about the libraries that make up the Apollo iOS SDK, see the [Apollo iOS SDK components section](#apollo-ios-sdk-components).

> <h4>Important: `ApolloCodegenLib` should not be linked to your application targets.</h4>
>
> It only supports macOS and should only be linked to by development tools that want to use the Apollo code generation engine.
> For most projects, it is recommended to use the Codegen CLI instead of using `ApolloCodegenLib` directly.

### Schema types module

> ** 2. How would you like to include your generated schema types?**

The generated schema types can be included in your project by embedding them directly in your application target, or as a separate module you include. This is configured through the [`output.schemaTypes`](./code-generation/codegen-configuration#schema-types) property of your codegen configuration. When setting up codegen for the first time, you will need to specify a path for the location of the generated module, and choose a module type to configure how the schema types module will be linked to your project.

For most projects, we recommend creating a separate schema module. This makes it possible to share your generated models across modules as your project grows. For simple, single target applications, you may choose to embed your schema types in your target

> For more information on configuring your schema types output see the [`output.schemaTypes` configuration documentation](./code-generation/codegen-configuration#schema-types).

#### Creating a schema module

This will allow you to link the schema module to each of your other modules that include or consume your generated operation models. The code generation engine can automate the creation of the schema types module for Swift Package Manager and is flexible enough to support manual configuration for projects with customized dependency needs.

Use the `.swiftPackageManager` or `.other` options to generate schema types that can be included as their own module.

> Most dependency managers like SPM and Cocoapods can automatically include your generated files in the module's directory. This means when generated files are added or removed from the generated module, they will be linked to your project automatically.

#### Embedded in your application

You may also include your schema types directly in a target that you have created.

For this you should use [`ModuleType.embeddedInTarget(name: String)`](./code-generation/codegen-configuration#embedded-in-target) for the [`output.schemaTypes.moduleType`](./code-generation/codegen-configuration#module-type) property. The generated schema types will be enclosed in a caseless namespace enum to prevent naming conflicts with types you may already have defined in your target.

> By using this option you are responsible for manually adding the generated files to your chosen target. When new generated files are created, or old ones are deleted, you will need to manually add/remove them from your target's "Compile Sources" build phase.

### Operation model generation

> ** 3. Where should your generated operations models be located?**

The next choice is to consider how operation models are used in your project. This is configured through the [`output.operations`](./code-generation/codegen-configuration#operations) property of your codegen configuration.

Your operation models can be included in your project in the way that makes the most sense for your needs. The only requirement is that your operation models need to have access to your schema types and to the `ApolloAPI` target to compile.

Generally, this decision falls into two categories:

#### Confined models

If you would like to organize your generated models by specific feature areas or modules within your project, use the [`OperationsFileOutput.relative(subpath: String?)`](./code-generation/codegen-configuration#relative-operations-output) value for the [`output.operations`](./code-generation/codegen-configuration#operations) property. The operation models will be generated relative to the `.graphql` files that define them.

This gives you the most flexibility and control over your operation models, as they can be generated anywhere in your project structure by organizing your `.graphql` operation definitions. With relative paths you can:
- Co-locate models with the feature code that uses them
- Include your models into different modules within in your project
- Organize them based on feature areas
- Or any other structure you would like

> When including your operation models in a multi-module project, you will need to ensure that any modules which include your operation models link to both your schema types module and the `ApolloAPI` library.

#### Shared models

You can also share your generated operation models across modules in your project either by including them within the shared schema types module, or by manually including them in another shared module.

##### Bundled with schema types

For most small projects, this is the most straightforward way of including your operation models. The operation models will be located in a sub-folder of the directory where your schema types are generated.

For this option use the [`.inSchemaModule`](./code-generation/codegen-configuration#operations-in-the-schema-module) option for the [`output.operations`](./code-generation/codegen-configuration#operations) property.

**If you are using a schema module**, the operation models will be included in the module, which can be imported by other modules in your project.

**If you are embedding your schema in another target**, the operations will also be included in the generated schema namespace that you include in your application target.

##### Absolute path

To generate your operation models into a single, specified directory, use the [`.absolute(path:)`](./code-generation/codegen-configuration#absolute-operations-output) option. These can then be manually included in your project however you see fit.

If you choose to generate the operation models in to an absolute path, you are you responsible for any module creation in order to link the generated files with the rest of your project. You will need to ensure that any targets which include your operation models link to both your schema types module and the `ApolloAPI` library.

### Supporting other configurations

There are many different possible combinations for a modular architecture and we've only shared examples of the most common configurations. Apollo iOS has many different options to support flexible configurations of the schema types and operation models. Please take the time to familiarize yourself with the [codegen configuration](./code-generation/codegen-configuration) and we're confident you can find a combination to suit your project needs.

## Apollo iOS SDK components

These are the libraries that compose the Apollo iOS package:

<table class="api-ref">
  <thead>
    <tr>
      <th>Description</th>
      <th>Usage</th>
    </tr>
  </thead>

<tbody>
<tr>
<td colspan="2">

#### `Apollo`

</td>
</tr>

<tr>
<td>

The core Apollo client library.

Includes the networking and caching APIs, including `ApolloClient` and `ApolloStore`.

</td>
<td>

Any targets that need to access these core components directly should be linked against `Apollo`.

</td>
</tr>
<tr>
<td colspan="2">

#### `ApolloAPI`

</td>
</tr>

<tr>
<td>

Includes the common components that are used by the generated models for your project.

</td>
<td>

Any targets that include your generated models should be linked to `ApolloAPI`.

The `Apollo` library has a dependency on this target, so any target that links to `Apollo` does not need to link to  `ApolloAPI` directly.

Because the generated models export the `ApolloAPI` library's interface, targets that consume generated models but do not contain them do not need to link to `ApolloAPI` directly.

</td>
</tr>

<tr>
<td colspan="2">

#### `ApolloSQLite`

</td>
</tr>

<tr>
<td>

Provides a `NormalizedCache` implementation backed by a `SQLite` database

Use this library if you would like to persist cache data across application lifecycles.
> See the [`SQLiteNormalizedCache` documentation](./caching/cache-setup#sqlitenormalizedcache) for more information on setting up a persistent SQLite cache.

</td>
<td>

This library only needs to be linked to your targets that configure the `SQLiteNormalizedCache` and pass it to the `ApolloStore`.

</td>
</tr>

<tr>
<td colspan="2">

#### `ApolloWebSocket`

</td>
</tr>

<tr>
<td>

Provides a web socket transport implementation used to support `GraphQLSubscription` operations

If your project uses GraphQL subscriptions, you must include this library.

> See the [Enabling GraphQL subscription support documentation](./fetching/subscriptions#enabling-graphql-subscription-support) for more information on setting up a web socket transport.

</td>
<td>

This library only needs to be linked to your targets that configure the `WebSocketTransport` and pass it to the `ApolloClient`.

</td>
</tr>

<tr>
<td colspan="2">

#### `ApolloTestSupport`

</td>
</tr>

<tr>
<td>

Includes the APIs for creating test mocks for your generated models

</td>
<td>

Link this library to *unit test targets* that need to create mocks of generated models.

</td>
</tr>

<tr>
<td colspan="2">

#### `ApolloCodegenLib`

</td>
</tr>

<tr>
<td>

Includes the code generation engine used to generate your GraphQL models

Use this library if you want to run the code generation engine from your own Swift executable targets.

> For most projects, it is recommended to use the Codegen CLI instead of using `ApolloCodegenLib` directly.

</td>
<td>

Link this library to development tools that want to use the Apollo code generation engine. This library only supports macOS.

> **Note: `ApolloCodegenLib` should not be linked to your application targets.**

</td>
</tr>

</tbody>
</table>

> **Note for Cocoapods users:**
>
> Cocoapods combines subspecs into a single target. This means that:
> - `ApolloAPI` will be merged into the `Apollo` target.
> - If the `ApolloSQLite` and `ApolloWebSocket` subspecs are used, they will also be merged into the `Apollo` target.
