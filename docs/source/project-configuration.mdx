---
title: Project configuration
description: Structuring a GraphQL application with the Apollo iOS SDK
---

Apollo iOS 1.0 can support complex applications composed of multiple modules _and_ monolithic application targets.

The code generation engine and modularized structure of the Apollo iOS SDK provide flexible configuration options, enabling you to structure your project as you like. 

This article covers the _models_ generated by Apollo iOS, the _modules_ that compose the Apollo iOS SDK, and how to structure these components in your project.

## Generated models

Apollo iOS generates the following groups of files for you:

* **[Operation models](#operation-models):** Models for the queries, mutations, subscriptions, and fragments defined in your GraphQL files.
* **[Schema types](#schema-types):** Your GraphQL schema's shared types and metadata (e.g., objects, enums, input objects).
* **[Test mocks](#test-mocks):** Test mock objects for your schema types, which you can use to create operation models in your tests.

#### Operation models

Apollo iOS generates _operation models_ from the files where you define your GraphQL operations (i.e., queries, mutations, subscriptions, and fragments). 

Operation models are classes that represent your GraphQL operations, which you can then use to make GraphQL requests (via `ApolloClient`).

Each operation model includes a set of type-safe response model objects, representing that operation's result. When `ApolloClient` successfully executes a GraphQL request, it returns an instance of the corresponding response model for the executed operation.

> To learn more about GraphQL operations, check out [Defining operations](./fetching/fetching-data#defining-operations).

#### Schema types

GraphQL schemas use a type system to define the shape of your available data. GraphQL operations (and your generated operation models) depend on a schema to know how to shape their operations to access a server's data.

Apollo iOS generates a collection of types that provide the properties and metadata about each type in your GraphQL schema (i.e., objects, interfaces, unions, enums, input objects, etc.). Your generated [operation models](#operation-models) reference these shared schema types to provide type information without duplicating code.

#### Test mocks

Apollo iOS enables you to generate test mock objects that you can use in your test targets. These mocks enable you to create operation models for your tests.

For more details, see [Test Mocks](./testing/test-mocks).

## Structuring your project

When including Apollo iOS in a new project, deciding _how_ to structure your project is an essential first step. A large part of this step is determining where your generated GraphQL models fit. 

You can include your GraphQL models in your main application target, spread them across many modules, or expose them as an independent module that multiple applications can use. Depending on the needs and constraints of your project, you'll configure the code generation engine and link to the Apollo iOS libraries differently.

Below, we cover the three primary decisions you'll need to make about your project structure.

### Single target vs multi-module

> ** 1. Will your application consist of a single application target or multiple modules?**

Depending on the size and complexity of your project, it might be built as a single monolithic application target _or_ be composed of multiple modules.

For a **monolithic** application, you can link your application target to the `Apollo` library. You can also optionally link to [`ApolloSQLite`](#apollosqlite) and/or [`ApolloWebSocket`](#apollowebsocket) to enable their functionality.

> For more information about the libraries that make up the Apollo iOS SDK, see the [Apollo iOS SDK](#apollo-ios-sdk-components).

To include the Apollo iOS SDK in a project with **multiple modules**:

1. Link `Apollo` to the modules that configure or use the networking and caching APIs.
    - Optionally, link `ApolloSQLite` and/or `ApolloWebSocket` to the module that sets up your `ApolloClient` to enable them.
2. Link `ApolloAPI` to the modules that only include generated models.

Additionally, you can optionally link `ApolloTestSupport` to your unit test target to create mocks of your generated models.

> ⚠️ **Do not link [`ApolloCodegenLib`](#apollocodegenlib) to your application targets.**
>
> `ApolloCodegenLib` only supports macOS, and you should only link it to development tools that want to use the Apollo code generation engine.

### Schema types module

> ** 2. How do you want to include your generated schema types?**

You can include generated schema types in your project by embedding them directly in your application target, or as a separate module.

You can configure this using the [`output.schemaTypes`](./code-generation/codegen-configuration#schema-types) property in your codegen configuration.

If you are setting up codegen for the first time, you'll need to specify a location path for the generated module, and specify a module type to [configure how the schema types module is linked](./code-generation/codegen-configuration#schema-types) to your project.

For most projects, we recommend creating a separate schema module. This makes it possible to share your generated models across modules as your project grows. For simple, single target applications, you may choose to embed your schema types in your target

#### Creating a schema module

This will allow you to link the schema module to each of your other modules that include or consume your generated operation models. The code generation engine can automate the creation of the schema types module for Swift Package Manager and is flexible enough to support manual configuration for projects with customized dependency needs.

Use the `.swiftPackageManager` or `.other` options to generate schema types that can be included as their own module.

> Most dependency managers like SPM and Cocoapods can automatically include your generated files in the module's directory. This means when generated files are added or removed from the generated module, they will be linked to your project automatically.

#### Embedded in your application

You may also include your schema types directly in a target that you have created.

For this you should use [`ModuleType.embeddedInTarget(name: String)`](./code-generation/codegen-configuration#embedded-in-target) for the [`output.schemaTypes.moduleType`](./code-generation/codegen-configuration#module-type) property. The generated schema types will be enclosed in a caseless namespace enum to prevent naming conflicts with types you may already have defined in your target.

> By using this option you are responsible for manually adding the generated files to your chosen target. When new generated files are created, or old ones are deleted, you will need to manually add/remove them from your target's "Compile Sources" build phase.

### Operation model generation

> ** 3. Where should your generated operations models be located?**

The next choice is to consider how operation models are used in your project. This is configured through the [`output.operations`](./code-generation/codegen-configuration#operations) property of your codegen configuration.

Your operation models can be included in your project in the way that makes the most sense for your needs. The only requirement is that your operation models need to have access to your schema types and to the `ApolloAPI` target to compile.

Generally, this decision falls into two categories:

#### Confined models

If you would like to organize your generated models by specific feature areas or modules within your project, use the [`OperationsFileOutput.relative(subpath: String?)`](./code-generation/codegen-configuration#relative-operations-output) value for the [`output.operations`](./code-generation/codegen-configuration#operations) property. The operation models will be generated relative to the `.graphql` files that define them.

This gives you the most flexibility and control over your operation models, as they can be generated anywhere in your project structure by organizing your `.graphql` operation definitions. With relative paths you can:
- Co-locate models with the feature code that uses them
- Include your models into different modules within in your project
- Organize them based on feature areas
- Or any other structure you would like

> When including your operation models in a multi-module project, you will need to ensure that any modules which include your operation models link to both your schema types module and the `ApolloAPI` library.

#### Shared models

You can also share your generated operation models across modules in your project either by including them within the shared schema types module, or by manually including them in another shared module.

##### Bundled with schema types

For most small projects, this is the most straightforward way of including your operation models. The operation models will be located in a sub-folder of the directory where your schema types are generated.

For this option use the [`.inSchemaModule`](./code-generation/codegen-configuration#operations-in-the-schema-module) option for the [`output.operations`](./code-generation/codegen-configuration#operations) property.

**If you are using a schema module**, the operation models will be included in the module, which can be imported by other modules in your project.

**If you are embedding your schema in another target**, the operations will also be included in the generated schema namespace that you include in your application target.

##### Absolute path

To generate your operation models into a single, specified directory, use the [`.absolute(path:)`](./code-generation/codegen-configuration#absolute-operations-output) option. These can then be manually included in your project however you see fit.

If you choose to generate the operation models in to an absolute path, you are you responsible for any module creation in order to link the generated files with the rest of your project. You will need to ensure that any targets which include your operation models link to both your schema types module and the `ApolloAPI` library.

### Supporting other configurations

There are many different possible combinations for a modular architecture and we've only shared examples of the most common configurations. Apollo iOS has many different options to support flexible configurations of the schema types and operation models. Please take the time to familiarize yourself with the [codegen configuration](./code-generation/codegen-configuration) and we're confident you can find a combination to suit your project needs.

## Apollo iOS SDK components

> **For Cocoapods users:**
>
> Cocoapods combines subspecs into a single target. This means that:
> - The [`ApolloAPI`](#apolloapi) is merged into the [`Apollo`](#apollo) target.
> - If you use the [`ApolloSQLite`](#apollosqlite) and [`ApolloWebSocket`](#apollowebsocket) subspecs, they are also merged into the `Apollo` target.

Libraries that compose the Apollo iOS package:

<table class="api-ref">
  <thead>
    <tr>
      <th>Description</th>
      <th>Usage</th>
    </tr>
  </thead>

<tbody>
<tr>
<td colspan="2">

#### `Apollo`

</td>
</tr>

<tr>
<td>

The core Apollo client library.

Includes the networking and caching APIs, including `ApolloClient` and `ApolloStore`.

</td>
<td>

Any targets that need to access these core components directly should be linked against `Apollo`.

</td>
</tr>
<tr>
<td colspan="2">

#### `ApolloAPI`

</td>
</tr>

<tr>
<td>

Includes the common components that are used by the generated models for your project.

</td>
<td>

Any targets that include your generated models should be linked to `ApolloAPI`.

The `Apollo` library has a dependency on this target, so any target that links to `Apollo` does not need to link to  `ApolloAPI` directly.

Because the generated models export the `ApolloAPI` library's interface, targets that consume generated models but do not contain them do not need to link to `ApolloAPI` directly.

</td>
</tr>

<tr>
<td colspan="2">

#### `ApolloSQLite`

</td>
</tr>

<tr>
<td>

Provides a `NormalizedCache` implementation backed by a `SQLite` database

Use this library if you would like to persist cache data across application lifecycles.

For more information on setting up a persistent SQLite cache, see[`SQLiteNormalizedCache`](./caching/cache-setup#sqlitenormalizedcache).

</td>
<td>

This library only needs to be linked to your targets that configure the `SQLiteNormalizedCache` and pass it to the `ApolloStore`.

</td>
</tr>

<tr>
<td colspan="2">

#### `ApolloWebSocket`

</td>
</tr>

<tr>
<td>

Provides a web socket transport implementation that supports `GraphQLSubscription` operations

If your project uses GraphQL subscriptions, you **must** include this library.

For more information, see [Enabling GraphQL subscription support](./fetching/subscriptions#enabling-graphql-subscription-support).
</td>
<td>

This library only needs to be linked to your targets that configure the `WebSocketTransport` and pass it to the `ApolloClient`.

</td>
</tr>

<tr>
<td colspan="2">

#### `ApolloTestSupport`

</td>
</tr>

<tr>
<td>

Includes the APIs for creating test mocks for your generated models

</td>
<td>

Link this library to *unit test targets* that need to create mocks of generated models.

</td>
</tr>

<tr>
<td colspan="2">

#### `ApolloCodegenLib`

</td>
</tr>

<tr>
<td>

Includes the code generation engine for generating GraphQL models.

Use this library if you want to run the code generation engine from your own Swift executable targets.

For most projects, **we strongly recommend using the Codegen CLI** instead of using `ApolloCodegenLib` directly.

</td>
<td>

Link this library to development tools that want to use the Apollo code generation engine. This library only supports macOS.

**`ApolloCodegenLib` shouldn't be linked to your application targets.**

</td>
</tr>

</tbody>
</table>
