---
title: Project organization
description: Structuring a GraphQL application
---

Apollo iOS 1.0 was designed to support complex applications composed of multiple modules as well as monolithic application targets. The code generation engine and modularized structure of the Apollo iOS SDK provide flexible configuration options that aim to make the Apollo libraries and your generated code work seamlessly for any project structure you prefer.

This guide helps you understand the contents of the models generated by Apollo iOS, the modules that compose the Apollo iOS SDK, and how to include these components in your project, depending on its structure.

## Generated models

There are three groups of files the that Apollo iOS generates for your project:

* **[Operation models](#operation-models):** The queries, mutations, subscriptions, and fragments defined in your GraphQL files.
* **[Schema types](#schema-types):** Your GraphQL schema's shared types and metadata such as objects, enums, input objects, etc.
* **[Test mocks](#test-mocks):** Test mocks objects for your schema types that enable creation of operation models for your tests.

#### Operation models

To execute GraphQL requests, you define a series of GraphQL operation files, which contain the queries, mutations, subscriptions, and fragments you can execute. Apollo iOS generates operation models from these definitions. These operation models are classes that represent your queries, mutations, and subscriptions, which can be used to make GraphQL requests with an `ApolloClient`.

Each operation model also includes a set of response models objects, which are type-safe models representing the response receieved by the operation. The `ApolloClient` returns instances of these response models upon successful completion of a GraphQL request using the corresponding operation model.

> To learn more about GraphQL operations, check out [Defining operations](../fetching/fetching-data#defining-operations).

#### Schema types

All GraphQL operations depend upon the types in their corresponding GraphQL schema. Your generated operation models also depend on information from the schema. Apollo iOS generates a collection of types that provide the necessary properties and metadata about the types in your GraphQL schema (ie. objects, interfaces, unions, enums, input objects, etc.). These shared schema types are referenced by your generated operation models to provide type information without duplicated code.

#### Test mocks

// TODO

## Apollo iOS SDK components

These are the libraries that compose the Apollo iOS package:

<table class="api-ref">
  <thead>
    <tr>
      <th>Description</th>
      <th>Usage</th>
    </tr>
  </thead>

<tbody>
<tr>
<td colspan="2">

#### `Apollo`

</td>
</tr>

<tr>
<td>

The core Apollo client library.

Includes the networking and caching APIs, including `ApolloClient` and `ApolloStore`.

</td>
<td>

Any targets that need to access these core components directly should be linked against `Apollo`.

</td>
</tr>
<tr>
<td colspan="2">

#### `ApolloAPI`

</td>
</tr>

<tr>
<td>

Includes the common components that are used by the generated models for your project.

</td>
<td>

Any targets that include your generated models should be linked to `ApolloAPI`.

The `Apollo` library has a dependency on this target, so any target that links to `Apollo` does not need to link to  `ApolloAPI` directly.

Because the generated models export the `ApolloAPI` library's interface, targets that consume generated models but do not contain them do not need to link to `ApolloAPI` directly.

</td>
</tr>

<tr>
<td colspan="2">

#### `ApolloSQLite`

</td>
</tr>

<tr>
<td>

Provides a `NormalizedCache` implementation backed by a `SQLite` database

Use this library if you would like to persist cache data across application lifecycles.
> See the [`SQLiteNormalizedCache` documentation](./caching/cache-setup#sqlitenormalizedcache) for more information on setting up a persistent SQLite cache.

</td>
<td>

This library only needs to be linked to your targets that configure the `SQLiteNormalizedCache` and pass it to the `ApolloStore`.

</td>
</tr>

<tr>
<td colspan="2">

#### `ApolloWebSocket`

</td>
</tr>

<tr>
<td>

Provides a web socket transport implementation used to support `GraphQLSubscription` operations

If your project uses GraphQL subscriptions, you must include this library.

> See the [Enabling GraphQL subscription support documentation](./fetching/subscriptions#enabling-graphql-subscription-support) for more information on setting up a web socket transport.

</td>
<td>

This library only needs to be linked to your targets that configure the `WebSocketTransport` and pass it to the `ApolloClient`.

</td>
</tr>

<tr>
<td colspan="2">

#### `ApolloTestSupport`

</td>
</tr>

<tr>
<td>

Includes the APIs for creating test mocks for your generated models

</td>
<td>

Link this library to *unit test targets* that need to create mocks of generated models.

</td>
</tr>

<tr>
<td colspan="2">

#### `ApolloCodegenLib`

</td>
</tr>

<tr>
<td>

Includes the code generation engine used to generate your GraphQL models

Use this library if you want to run the code generation engine from your own Swift executable targets.

> For most projects, it is recommended to use the Codegen CLI instead of using `ApolloCodegenLib` directly.

</td>
<td>

Link this library to development tools that want to use the Apollo code generation engine. This library only supports macOS.

> **Note: `ApolloCodegenLib` should not be linked to your application targets.**

</td>
</tr>

</tbody>
</table>

## Configuring your project

When including Apollo iOS in a new project, it's important to decide how you will structure your project, and where your generated GraphQL models fit in that project. Your GraphQL models can be included in your main application target, spread out across many modules, or exposed as an independent module that can be used by multiple applications. Depending on the needs and constraints of your project, you will need to configure the code generation engine and link to the Apollo iOS libraries differently.

For the most common use cases, there are two primary decisions to be made about your project structure:

> For more specific customization, read about the configuration options below.

** 1. Will your application consist of a single application target or multiple modules?**

<table>
<thead>
    <tr>
      <th>Apollo iOS Targets</th>
      <th>Code Generation</th>
    </tr>
</thead>

<tbody>
<tr>
<td colspan="2">

#### Single Target

</td>
</tr>

<tr>
<td>

- Link your target to the `Apollo` library.
    - Optionally, link to `ApolloSQLite` and/or `ApolloWebSocket` to enable their functionality.

</td>
<td>

- Configure the code generation option `output.schemaTypes.moduleType` to `.embeddedInTarget(name:)` to generate the schema types in a namespace that you can include in your application target.

</td>
</tr>

<tr>
<td colspan="2">

#### Multi-module

</td>
</tr>

<tr>
<td>

- Link `Apollo` to the modules that configure or use the networking and caching APIs.
    - Optionally, link `ApolloSQLite` and/or `ApolloWebSocket` to the module that sets up your `ApolloClient` to enable their functionality.
- Link `ApolloAPI` to the modules that only include generated models.
- Optionally, link `ApolloTestSupport` to your unit test target to create mocks of your generated models.

</td>
<td>

- Configure the code generation option `output.schemaTypes.moduleType` to `.swiftPackageManager` or `.other` to generate the schema types as a seperate module that can be linked to your application modules.

</td>
</tr>

</tbody>
</table>

> #### **Important: `ApolloCodegenLib` should not be linked to your application targets.**
> It only supports macOS and should only be linked to by development tools that want to use the Apollo code generation engine.
> For most projects, it is recommended to use the Codegen CLI instead of using `ApolloCodegenLib` directly.

> **Note for Cocoapods users:**
>
> Cocoapods combines subspecs into a single target. This means that:
> - `ApolloAPI` will be merged into the `Apollo` target.
> - If the `ApolloSQLite` and `ApolloWebSocket` subspecs are used, they will also be merged into the `Apollo` target.

** 2. Where should your generated operations models be located?**

By default, the operation models will be generated in a sub-folder of the directory where your schema is generated. All of your operation models will be included in the schema module, or namespace if using `embeddedInTarget(name:)`.

Alternatively, you can configure code generation to generate operation models relative to the `.graphql` files that define them. This allows you to customize the location of your operation models and setup your project to suit your specific needs. You can co-locate models with the feature code that uses them; generate your models into different modules within in your project; organize them based on feature areas; or any other structure you would like.

Lastly, you can generate all of your operations into a single specified directory, which can be manually included in your project however you see fit.






There are three options for where to generated your operation models:
- By default, the operation models will be generated in a sub-folder of the directory where your schema is generated. If your schema types are packaged as a shared module, all of your operation models will be included in the schema module.

-----

// TODO Schema types - config

Your operation models need to have access to these schema types to compile. this can be done by including them in the same module, or by creating a shared module that contains your schema types and linking your operation models against it. The code generation engine can automate the creation of the schema types module for certain dependency managers and is flexible enough to support manual configuration for projects with customized dependency needs.

> Note: Apollo iOS supports the Swift Package Manager and CocoaPods dependency managers. If your project uses Carthage you will need to manually build the xcframework and integrate that into your project.

The schema types module is configured through the [`output.schemaTypes`](./codegen-configuration#schema-types) property. You will need to specify a path for the location of the generated module, and choose a module type to configure how the schema types module will be linked to your project.

> Note: It is important to consider your project structure and how you would like to integrate the generated code before choosing a module type.

See the [example configurations](#example-configurations) below for some common configurations.

//. ## Operation models

These can be generated into the schema types module, generated into other existing modules, or they can be completely separated to support custom configurations. The difference in each of the configurations is how they are linked and exposed to the rest of your project.

> To learn more about GraphQL operations, check out [Defining operations](../fetching/fetching-data#defining-operations).

// ## Test mocks

It is recommended that test mock objects should always be contained within their own module.

The code generation engine can automate the creation of the module when [Swift Package Manager](/codegen-configuration#test-mocks-in-a-swift-package) is used as the module type for the shared schema types module. This will result in another product being defined in the `Package.swift` file which can be declared as a dependency for your test targets.

When another dependency manager is used to link Apollo iOS to your project you are responsible for the creation of the module and linking it with your project. For this configuration you will need to use the [`TestMockFileOutput.absolute(path: String)`](./codegen-configuration#absolute-test-mocks-output) value for the [`output.testMocks`](./codegen-configuration#test-mocks) property.

> To learn more about using test mocks to mock your operation models, see the [Test mocks documentation](../testing/test-mocks).

## Example configurations

### Single target

This is the simplest form of project architecture and will result in a configuration without any generated module. By using this option you're declaring that you will manually add the generated files to your application target.

For this you should use [`ModuleType.embeddedInTarget(name: String)`](./codegen-configuration#embedded-in-target) for the [`output.schemaTypes.moduleType`](./codegen-configuration#module-type) property. The generated schema types will be placed into their respective subfolders and all the generated schema types will be enclosed in a caseless namespace enum to prevent naming conflicts with types you may already have defined in your target.

Since there is only one target you can use any of the [`OperationsFileOutput`](/codegen-configuration#operations) values. The only difference will be where the generated files are placed.

### Multiple modules using Swift Package Manager

This configuration is suitable when you are using Swift Package Manager as the dependency manager to link Apollo iOS to your project.

For this you should use [`ModuleType.swiftPackageManager`](./codegen-configuration#swift-package-manager) for the [`output.schemaTypes.moduleType`](./codegen-configuration#module-type) property. The generated schema types will be placed into their respective subfolders and the code generation engine will automate the creation of a Swift package. The generated `Package.swift` file will define the module which can be added to your project, linking the shared schema types module with the rest of your code.

The next choice is to consider how operation models are used in your project.

#### Confined models

If the generated operation models are used only within specific modules, then you will want to use the [`OperationsFileOutput.relative(subpath: String?)`](./codegen-configuration#relative-operations-output) value for the [`output.operations`](./codegen-configuration#operations) property. This will locate the generated operation models relative to the GraphQL operation definition file within each respective module.

#### Shared models

If the generated operation models are shared between modules then you have the choice of including them within the shared schema types module or at another location of your choice but without any module automation.

Including the operation models in the shared schema types module is configured by using the [`OperationsFileOutput.inSchemaModule`](./codegen-configuration#operations-in-the-schema-module) value for the [`output.operations`](./codegen-configuration#operations) property. The benefit of this configuration is that the SPM module definition will be automated and there is little that you need to do in order to use the generated operation models.

If you choose to generate the operation models in another location, you are declaring that you will be responsible for any module creation in order to link the generated files with the rest of your project. The generated operation model files will include an `import` statement to the shared schema types module. For this configuration you will need to use the [`OperationsFileOutput.absolute(path: String)`](./codegen-configuration#absolute-operations-output) value for the [`output.operations`](./codegen-configuration#operations) property.

### Multiple modules using CocoaPods

This configuration is suitable when you are using CocoaPods as the dependency manager to link Apollo iOS to your project.

For this you should use [`ModuleType.other`](./codegen-configuration#other-schema-module-types) for the [`output.schemaTypes.moduleType`](./codegen-configuration#module-type) property. The generated schema types will be placed into their respective subfolders but the code generation engine will not automate the creation of the pod. You are responsible for the creation of the shared schema types [podspec](https://guides.cocoapods.org/syntax/podspec.html) which declares the CocoaPods pod to the rest of your project.

The next choice is to consider how operation models are used in your project.

> Note: The [`OutputOptions.cocoapodsCompatibleImportStatements`](./codegen-configuration#output-options) configuration property is specific to the CocoaPods dependency manager and will generate import statements that are compatible with including Apollo via Cocoapods.

#### Confined models

If the generated operation models are used only within specific modules, then you will want to use the [`OperationsFileOutput.relative(subpath: String?)`](./codegen-configuration#relative-operations-output) value for the [`output.operations`](./codegen-configuration#operations) property. This will locate the generated operation models relative to the GraphQL operation definition file within each respective module.

#### Shared models

If the generated operation models are shared between modules then you have the choice of including them within the shared schema types module or at another location of your choice.

Including the operation models in the shared schema types module is configured by using the [`OperationsFileOutput.inSchemaModule`](./codegen-configuration#operations-in-the-schema-module) value for the [`output.operations`](./codegen-configuration#operations) property. The benefit of this configuration is that the operation models will be exposed along with the shared schema types and there is little that you need to do in order to use the generated operation models.

If you choose to generate the operation models in another location, you are declaring that you will be responsible for any module creation in order to link the generated files with the rest of your project. The generated operation model files will include an `import` statement to the shared schema types module. For this configuration you will need to use the [`OperationsFileOutput.absolute(path: String)`](./codegen-configuration#absolute-operations-output) value for the [`output.operations`](./codegen-configuration#operations) property.

### Supporting other configurations

There are many different possible combinations for a modular architecture and we've only shared examples of the most common configurations. Apollo iOS has many different options to support flexible configurations of the schema types and operation models. Please take the time to familiarize yourself with the [codegen configuration](./codegen-configuration) and we're confident you can find a combination to suit your project needs.
