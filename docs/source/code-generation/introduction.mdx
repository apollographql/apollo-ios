---
title: Code Generation
---

Apollo iOS generates operation objects for your GraphQL operations, providing a type-safe way to construct operations and provide values for input variables in your Swift code.

Each generated operation contains a set of robust, strongly-typed models for its response. These generated models help you access your GraphQL response data in a type-safe and flexible format. You don't need to deal with parsing JSON responses or passing around dictionaries of values that require manual casting. You also don't need to write model types yourself, because models are generated from the GraphQL operations you define.

Because generated response models are operation-specific, they include properties _only_ for the GraphQL fields included in their corresponding operation. This means you can rely on the Swift type checker to flag data access errors at compile time.

## GraphQL source files

To generate models, Apollo iOS requires two input sources:

1. **A GraphQL schema**

 The **GraphQL schema** is a list of all of the types that are available and the fields you can query on those types. The schema can be thought of as a contract of what it's *possible* to ask for.

 A schema is provided by every GraphQL server. Tou can generally get your scheme from your server via an introspection query or from [Apollo Studio](https://www.apollographql.com/docs/studio/).

 > Apollo iOS provides tools to help you obtain your GraphQL schema. See [Downloading a schema](./downloading-schema/) for more details.

2. **A set of GraphQL operations**

  A **GraphQL operation** defines an interaction with your schema. A GraphQL operation can be a query, a mutation, or a subscription. All operations define a set of fields from the types in your schema to fetch data for. The operation definition determines what the response your GraphQL server provides will include.

  In order for Apollo to generate useful models, you must define at least one operation. This tells us what data you would like to fetch.

  > For more information on GraphQL operation definitions see [Defining operations](./fetching/fetching-data#defining-operations).

Apollo iOS combines the type information from your schema with your operation definitions to generate models. The schema provides the information needed to generate type-safe models, and your operations define the shape and structure of the generated models.

The Apollo iOS Code Generation Engine parses your schema and operations and ensures that your operations are valid to be performed against the schema provided. It generates modesl that include all of the necessary information to create type-safe operations, send those operations as network requests, and parse the response data onto the type-safe response models.

The most basic way to think about this is the following equation:

**Schema + Operations = Code**

If you don't have any operations, our code generator won't know what information you want to fetch, so it can't generate the code to send a request or parse a result. If you don't provide a schema, our code generator won't know if your operations are valid or what types any of the fields you want to fetch will return, so it can't generate type-safe models. If you have both, the appropriate checks can be made and type-safe code can be generated.

## Running code generation

The Apollo code generation engine can be run using one of two methods:

### [The Codegen CLI](./codegen-cli)

**This is the recommended method for most use cases.**

The [Codegen CLI](./codegen-cli) is the simplest way to get started with Apollo iOS. The correct version of the CLI is automatically bundled with our SPM and Cocoapod packages, so you never have to worry about installation or updates.

### [Swift Scripting](./run-codegen-in-swift-code)

For advanced use cases, you can include our code generation engine within your own Swift project.

> To learn more about running code generation from Swift code, check out [Running codegen in Swift code](./run-codegen-in-swift-code).







---
# UNDER CONSTRUCTION
## FROM Fetching queries

To generate classes, Apollo iOS requires your server's schema, along with all of the `.graphql` files that contain your defined operations. It uses these to generate code you can use to execute queries and access typed results.

All `.graphql` files in your project (or the subset you specify as input to the `Codegen CLI` if you customize your code generation configuration) will be combined and treated as one big GraphQL document.

This means that fragments defined in one .graphql file are available across all .graphql files. However, it also means that operation and fragment names must be unique (and validation errors will occur if they aren't).

# Run codegen as a build step

To run code generation as part of the Xcode build process, you need to create a build step that runs before "Compile Sources" to invoke a wrapper script.

The wrapper script calls through to the included binaries and files that constitute the `apollo` command-line interface. This helps ensure that you can use our tooling without having to worry about mismatched versioning between libraries.

> ðŸ“£ **Check it out:** Instead of writing the rest of this in Bash, try using our new [Swift Scripting Library](./swift-scripting), now in Beta! It supports downloading a schema and generating code.

The location of this wrapper script depends on how you've integrated Apollo into your project, but these first steps are always the same:

1. On your application target's **Build Phases** settings tab, click the **+** icon and choose **New Run Script Phase**.
2. In the created Run Script, change its name to **Generate Apollo GraphQL API**.
3. Drag this new run script just above **Compile Sources** in your list of **Build Phases** so that it executes _before_ your code is compiled.
4. Add the contents of the appropriate run script for the package manager you're using:

<a name="swift-package-manager-run-script" />
<SPMRunScriptPanel />

<a name="cocoapds-run-script" />
<PodsRunScriptPanel />

<a name="carthage-run-script" />
<CarthageRunScriptPanel />


### Troubleshooting

If you get this error:

> `Cannot find GraphQL schema file [...]`

The script can't locate your schema file. Double check the path you've used.

If you get this error:

> `No operations or fragments found to generate code for.`

You haven't defined at least one `.graphql` file with a valid operation in your build tree.

If you need to validate the structure of a GraphQL operation, you can test it against your GraphQL server using [Apollo Sandbox](https://studio.apollographql.com/sandbox).

## Advanced codegen tips and tricks

After you get up and running, here are a few improvements you can make to your codegen process.

### Prevent unnecessary recompilation

#### Set up input and output files in your build phase

If you're using a tool like Interface Builder or SwiftUI to talk to a module with its own code generation build step, this is helpful to prevent the `API.swift` file from causing an auto-regeneration loop.

For example, if you're using something like this to run your code generation for a target called `YourTarget`:

```
"${SCRIPT_PATH}"/run-bundled-codegen.sh codegen:generate --target=swift --includes=./**/*.graphql --localSchemaFile="schema.json" API.swift
```

Assuming you've set the script to run from `$(SRCROOT)/YourTarget`, you can add `$(SRCROOT)/YourTarget/**/*.graphql` (the path you're running it from + the glob you're passing to the `includes` CLI parameter) to the list of `Input Files` for your Apollo Run Script Build phase. Then, you can add `$(SRCROOT)/YourTarget/API.swift` (the path you're running it from + the output file) to the list of `Output Files`:

<img class="screenshot" src="screenshot/input_output_files.png" alt="Setting input and output files" />

This should prevent automatic rebuild cycles if none of the `InputFiles` are changed. The script *will* still run if you explicitly build and run.

There's an [open issue to auto-generate input and output file lists](https://github.com/apollographql/apollo-ios/issues/636) which will be addressed as part of Apollo iOS 1.0, but this will help until that's done.

#### Write to a temporary file

If for some reason the input/output file setup above doesn't work for you, you can also decide to first write the file to a temporary location, and then compare this temporary file to the current one. Then, only when the files differ you move the temporary file into place.

For a target called `YourTarget`, the script could look something like this:

```bash
"${SCRIPT_PATH}"/run-bundled-codegen.sh codegen:generate --target=swift --includes=./**/*.graphql --localSchemaFile="schema.json" "${SRCROOT}/YourTarget/API.swift.new"
if ! diff -q "${SRCROOT}/YourTarget/API.swift.new" "${SRCROOT}/YourTarget/API.swift"; then
  mv "${SRCROOT}/YourTarget/API.swift.new" "${SRCROOT}/YourTarget/API.swift"
else
  rm "${SRCROOT}/YourTarget/API.swift.new"
fi
```

### Generate multiple files in a folder instead of one large file

Instead of passing a single `API.swift` file, you can pass a (pre-existing) relative folder path such as `API` as the final parameter. This causes the codegen to create individual files and place them in that folder.

With small sets of `graphql` files this is usually unnecessary, but with large sets that can cause `API.swift` to be huge. Dividing it up like this can help significantly reduce compilation time.
